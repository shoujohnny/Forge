#lang racket/base

(require forge/sigs-structs)
(require forge/breaks)
(require forge/lang/ast)
(require forge/lang/bounds)
(require forge/shared
         (prefix-in tree: forge/utils/lazy-tree)
         forge/last-checker
         forge/choose-lang-specific)
(require (prefix-in @ (only-in racket/base >= not - = and or max > < +))
         (only-in racket match first rest empty empty? set->list list->set set-intersect set-union
                         curry range index-of pretty-print filter-map string-prefix? string-split thunk*
                         remove-duplicates subset? cartesian-product match-define cons? set-subtract)
          racket/hash)
(require (only-in syntax/srcloc build-source-location-syntax))

; Solver-specific backend initializer functions
(require (prefix-in pardinus: (only-in forge/pardinus-cli/server/kks start-server)))
(require (prefix-in smtlib: (only-in forge/solver-specific/cvc5-server start-server)))

; Separate solver-specific translation for each solver backend
(require (only-in forge/solver-specific/pardinus
                  send-to-kodkod get-next-kodkod-model))
(require (only-in forge/solver-specific/cvc5-tor
                  send-to-cvc5-tor get-next-cvc5-tor-model))

; Disable DrRacket GUI extension/tool
;(require "drracket-gui.rkt")

(provide send-to-solver reset-run-name-history! stop-solver-process!)

(define no-version-printed-yet #t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;    Run Logic    ;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Will be a Server-ports tuple if a server is active. 
(define server-state (box #f))
; In order to prevent a bad crash, keep track of run-names used in the past, 
; and throw a friendlier error if one is re-used. 
(define run-name-history (box (list)))
(define (reset-run-name-history!)
  (set-box! run-name-history (list)))

; This function is provided for scripting tests, but it is volatile; don't rely on it.
(define (stop-solver-process!)
  (when (unbox server-state)
    ((Server-ports-shutdown (unbox server-state)))
    (set-box! server-state #f)))

; send-to-solver :: Run-spec -> Stream<model>, List<Symbol>
; Given a Run-spec structure, processes the data and communicates it to KodKod-CLI;
; then produces a stream to produce instances generated by KodKod, 
; along with a list of all of the atom names for sig atoms.
(define (send-to-solver run-spec run-command #:run-name [run-name (gensym)])
  (do-time "send-to-solver")
  
  ; In case of error, highlight an AST node if able. Otherwise, focus on the offending run command.
  (define (raise-run-error message [node #f])
    (if node
        (raise-forge-error #:msg message
                           #:context (nodeinfo-loc (node-info node)))
        (raise-forge-error #:msg message
                           #:context run-command)))
  
  (when (member run-name (unbox run-name-history))
    (raise-run-error (format "Run name ~a was re-used; please use a different run name.~n" run-name)))
  (set-box! run-name-history (cons run-name (unbox run-name-history)))

  ; Print version number, so students know to update
  (when (and no-version-printed-yet (@>= (get-verbosity) VERBOSITY_LOW))
    (set! no-version-printed-yet #f)
    (printf "Forge version: ~a~n" forge-version)
    (let* ([git-info (forge-git-info)]
          [git-valid (pair? git-info)])
      (when git-valid
        (apply printf " branch: ~a~n commit: ~a~n timestamp: ~a~n" git-info)
      ; Check local forge version vs. latest version on main branch
      (let ([curr-forge-version (curr-forge-version)])
        (cond [(and (not (void? curr-forge-version)) (and git-valid (equal? (car git-info) "main"))) ; git install, main branch, successful retrieve
                  (if (equal? forge-version curr-forge-version)
                      (printf "Forge is up-to-date.~n")
                      (printf "Forge is out-of-date. You are on version ~a, but main is on version ~a.~n"
                              forge-version curr-forge-version))]
              [(or (void? curr-forge-version) (and git-valid (not (equal? (car git-info) "main")))) ; unsucessful git retrieve, or git install, but branched
                  (printf "Skipping version check vs. main branch.~n")]
              [(and (not git-valid) (not (void? curr-forge-version))) ; package install, successful retrieve
                  (if (equal? forge-version curr-forge-version)
                      (printf "Forge is up-to-date.~n")
                      (printf "Forge is out-of-date. You are on version ~a, but main is on version ~a.~n"
                              forge-version curr-forge-version))]))))
    
    (printf "To report issues with Forge, please visit ~a~n"
            "https://report.forge-fm.org"))
  
  ; Do relation breaks from declarations
  (define relation-constraints 
    (apply append
           (for/list ([relation (get-relations run-spec)])
             (match (Relation-breaker relation)
               [#f (list)]
               ['default (list)]
               ['pfunc (let* ([rel relation]
                              [sigs (map (lambda (sig-thunk) (sig-thunk))
                                         (Relation-sigs-thunks relation))]
                              [left-sig (get-sig run-spec (first sigs))]
                              [sig-rel left-sig])
                         (list (all ([s sig-rel])
                                 (lone (join s rel)))))]
               [other (break relation other)
                      (list)]))))

  (define-values (sig-to-bound relation-to-bound all-atoms)
    (get-bounds run-spec raise-run-error))

  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))
  
  ; Get new bounds and constraints from breaks
  (define-values (total-bounds break-preds)
    (let* ([sig-bounds (map (compose (curry hash-ref sig-to-bound )
                                     Sig-name)
                            (get-sigs run-spec))]
           [relation-bounds (map (compose (curry hash-ref relation-to-bound )
                                          Relation-name)
                                 (get-relations run-spec))]
           [total-bounds (append sig-bounds relation-bounds)]

           [sigs (get-sigs run-spec)]
           [sig-rels (filter (lambda (sig) (@not (equal? (Sig-name sig) 'Int))) sigs)]
           [upper-bounds (for/hash ([sig sigs]) 
                           (values sig
                                   (map car (bound-upper (hash-ref sig-to-bound (Sig-name sig))))))]
           [relations-store (for/hash ([relation (get-relations run-spec)]
                                       #:unless (equal? (Relation-name relation) 'succ))
                              (values relation (get-sigs run-spec relation)))]
           [extensions-store (for/hash ([sig sigs]
                                        #:when (Sig-extends sig))
                               (values sig (get-sig run-spec (Sig-extends sig))))])
      ;(printf "args-- total-bounds : ~a~n args-- sig-rels : ~a~n args-- upper-bounds : ~a~n" total-bounds sig-rels upper-bounds )
      (constrain-bounds total-bounds sig-rels upper-bounds relations-store extensions-store)))
  ;(printf "after-- total-bounds : ~a~n" total-bounds)
  (clear-breaker-state)

  (define sigs-and-rels
    (append (State-sig-order (Run-spec-state run-spec))
            (State-relation-order (Run-spec-state run-spec))))
  (set! total-bounds (map (lambda (name) 
                            (findf (lambda (b) 
                                     (equal? name (string->symbol (relation-name (bound-relation b)))))
                                   total-bounds)) 
                          sigs-and-rels))

  (when (@>= (get-verbosity) VERBOSITY_DEBUG)
    (displayln "--------------------------")
    (printf "Original PBindings: ~n~a~n~n" (Bound-pbindings (Run-spec-bounds run-spec)))
    (printf "sig-to-bound: ~n~a~n~n" sig-to-bound)
    (printf "relation-to-bound: ~n~a~n~n" relation-to-bound)
    (printf "all-atoms: ~n~a~n~n" all-atoms)
    (printf "total-bounds: ~n~a~n~n" total-bounds)
    (displayln "--------------------------"))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Prepare backend solver to receive bounded problem
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; Initializing our backend process, and getting ports for communication with it.
  ; This was originally just Kodkod; some of that terminology remains.
  (define backend (get-option run-spec 'backend))
  (define-values (stdin stdout stderr shutdown is-running?)
    (cond
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; if there is an active server state, and the server is running
      [(and (unbox server-state) ((Server-ports-is-running? (unbox server-state))))
       (define sstate (unbox server-state))
       (when (@> (get-verbosity) VERBOSITY_LOW)
        (printf "~a solver process already running. Preparing to start new run with id ~a.~n" backend run-name))
       (values (Server-ports-stdin sstate) (Server-ports-stdout sstate) 
               (Server-ports-stderr sstate) (Server-ports-shutdown sstate)
               (Server-ports-is-running? sstate))]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; Backend=Kodkod; server isn't active/running
      [(equal? backend 'kodkod)
       (raise "Pure Kodkod backend is no longer supported; please use `pardinus` backend instead.")]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; Backend=smtlibtor; server isn't active/running
      [(equal? backend 'smtlibtor)
       (printf "Will use SMT-LIB-v2 output. This is experimental functionality. Please ensure that cvc5 is on your path.~n")
       (smtlib:start-server 'stepper (get-option run-spec 'problem_type))]
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; Backend=Pardinus; server isn't active/running
      [(equal? backend 'pardinus)
       (when (@>= (get-verbosity) VERBOSITY_HIGH)
         (printf "Starting/restarting Pardinus server (prior state=~a)...~n" (unbox server-state)))
       (pardinus:start-server
        'stepper ; always a stepper problem (there is a "next" button)
        ; 'default, 'temporal, or 'target (tells Pardinus which solver to load,
        ;  and affects parsing so needs to be known at invocation time)
        (get-option run-spec 'problem_type)
        ; control version of java used (by path string)
        (get-option run-spec 'java_exe_location))]

      [else (raise (format "Invalid backend: ~a" backend))]))

  ; Confirm that if the user is invoking a custom solver, that custom solver exists
  (define solverspec (cond [(symbol? (get-option run-spec 'solver))
                            (get-option run-spec 'solver)]
                           [else (string-append "\"" (get-option run-spec 'solver) "\"")]))
  (unless (or (symbol? (get-option run-spec 'solver))
              (file-exists? (get-option run-spec 'solver)))
    (raise-user-error (format "option solver specified custom solver (via string): ~a, but file did not exist." 
                              (get-option run-spec 'solver))))
  
  ; Print configure and declare univ size
  ; Note that target mode is passed separately, nearer to the (solve) invocation
  (define bitwidth (get-bitwidth run-spec))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Generate top-level constraint for this run, execute last-checker
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define (maybe-alwaysify fmla)
    (if (equal? 'temporal (get-option run-spec 'problem_type))
        (always/info (node-info fmla) fmla)
        fmla))
  
  ; If in temporal mode, need to always-ify the auto-generated constraints but not the
  ;   predicates that come from users
  (define raw-implicit-constraints
    (append (get-sig-size-preds run-spec sig-to-bound #:error raise-run-error)
            (get-relation-preds run-spec)
            (get-extender-preds run-spec)
            relation-constraints
            break-preds))
  (define conjuncts-implicit-constraints
    (apply append (map maybe-and->list raw-implicit-constraints)))
  (define implicit-constraints
    (map maybe-alwaysify conjuncts-implicit-constraints))
  (define explicit-constraints
    (apply append (map maybe-and->list (Run-spec-preds run-spec)))) 
  (define run-constraints 
    (append explicit-constraints implicit-constraints))

  ; Run last-minute checks for errors  
  (for-each (lambda (c)
              (checkFormula run-spec c '() (get-checker-hash)))
            run-constraints)
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Beginning to send to solver. All type-checking must be complete _before_ this point.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (define get-next-model
    (cond [(equal? backend 'smtlibtor)
           (begin
             (define-values (all-rels core-map)
               (send-to-cvc5-tor run-name run-spec bitwidth all-atoms solverspec total-bounds bound-lower bound-upper run-constraints stdin stdout stderr))
             (lambda (mode) (get-next-cvc5-tor-model is-running? run-name all-rels all-atoms core-map stdin stdout stderr mode
                                                     #:run-command run-command)))]        
          [(equal? backend 'pardinus)
           (begin
             (define-values (all-rels core-map)
               (send-to-kodkod run-name run-spec bitwidth all-atoms solverspec total-bounds bound-lower bound-upper run-constraints stdin stdout stderr))
             (lambda (mode) (get-next-kodkod-model is-running? run-name all-rels all-atoms core-map stdin stdout stderr mode)))]   
          [else (raise (format "Invalid backend: ~a" backend))]))
           
     
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; DO NOT ADD MORE MESSAGES TO SOLVER AFTER THIS POINT
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (define (next-button type)
    (tree:make-node (get-next-model type) next-button))
  (define results
    (tree:make-node (get-next-model 'start) next-button))

  (set-box! server-state (Server-ports stdin stdout stderr shutdown is-running?))

  (values results 
          all-atoms 
          (unbox server-state)
          (Kodkod-current (length run-constraints) 0 0)
          ; This becomes the "kodkod-bounds" field of the Run that is eventually created.
          total-bounds))


(define (get-bounds run-spec raise-run-error)
  ; Send user defined partial bindings to breaks
  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))
  
  ; Get KodKod names, min sets, and max sets of Sigs and Relations
  (define-values (sig-to-bound all-atoms) ; Map<Symbol, bound>, List<Symbol>
    (get-sig-bounds run-spec raise-run-error))

  (define relation-to-bound ; Map<Symbol, bound>
    (get-relation-bounds run-spec sig-to-bound raise-run-error))

  (values sig-to-bound relation-to-bound all-atoms))

; Produce a single AST node to blame for a given relation's bound, or #f if none available
(define (get-blame-node run-spec the-rel)
  (cond [(or (not (node/expr/relation? the-rel))
             (not (Run-spec? run-spec)))
         #f]
        [else        
         (define result (hash-ref (Bound-orig-nodes (Run-spec-bounds run-spec)) the-rel #f))
         (and result (first result))]))

; get-sig-bounds :: Run-spec -> Map<Symbol, bound>, List<Symbol>
; Given a Run-spec, assigns names to each sig, assigns minimum and maximum 
; sets of atoms for each, and find the total number of atoms needed (including ints).
(define (get-sig-bounds run-spec raise-run-error)
  ;;;;; Helpers for extracting declared relational bounds from the run-spec
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))  
  (define (get-bound-lower sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding ;; !!!
          (map car (set->list (sbound-lower pbinding)))))
  (define (get-bound-upper sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding
          (sbound-upper pbinding)
          (map car (set->list (sbound-upper pbinding)))))

  ;;;;; Helpers for extracting declared numeric scopes from the run-spec
  (define scopes (Run-spec-scope run-spec))
  (define (get-scope-lower sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-lower scope)))
  (define (get-scope-upper sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-upper scope)))
  (define (get-scope-lower-default sig)
    (let ([actual (get-scope-lower sig)])
      (or actual
          (Range-lower (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))
  (define (get-scope-upper-default sig)
    (let ([actual (get-scope-upper sig)])
      (or actual
          (Range-upper (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))



  ; Map<Symbol, int>; keeps track of what the "next" generated atom ID should be
  (define curr-atom-number (make-hash))

  ; Sig -> Listof<Symbol>; the atom names declared by the user in a partial instance
  (define all-user-atoms 
    (apply append (for/list ([sig (get-sigs run-spec)]
                             #:when (hash-has-key? pbindings sig))
      (define bound (hash-ref pbindings sig))
      (map car (set->list (@or (sbound-upper bound) (sbound-lower bound)))))))

  ; Generate the "next" atom ID for a given sig, based on what's been generated/declared so far
  (define (get-next-name sig)
    (define atom-number (add1 (hash-ref curr-atom-number (Sig-name sig) -1)))    
    (let loop ([atom-number atom-number])
      (hash-set! curr-atom-number (Sig-name sig) atom-number)
      (define new-name (string->symbol (format "~a~a" (Sig-name sig) atom-number)))
      (if (member new-name all-user-atoms)
          (loop (add1 atom-number))
          new-name)))

  ; Generate <num> new names for sig <sig>
  (define (generate-names sig num)
    (map (thunk* (get-next-name sig)) (range num)))

  ; Overall bounds data structures, will be modified as this procedure executes
  (define lower-bounds (make-hash))
  (define upper-bounds (make-hash))

  ; Helper to populate a sig's lower bound based on relational bound given
  ;   If any #:one children lack tuple-based lower bounds, there is a risk of inconsistency
  ;   since those children must receive a fresh atom name to denote (and for #:one sigs, LB=UB)
  (define (fill-lower-by-bound sig)
    (define children-lowers
      (apply append (map fill-lower-by-bound (get-children run-spec sig))))
    (define curr-lower (get-bound-lower sig))

    ; Check that Forge isn't be asked to choose atoms ambiguously
    (when (and (not curr-lower) (Sig-one sig))
      ;; TODO: issue here is we would rather report the ancestor too, and ideally the stxloc for the bind
      (raise-run-error (format "Example or inst named members for an ancestor of 'one' sig ~a but no member name was given for ~a. This can result in inconsistency; please give bounds for ~a." (Sig-name sig) (Sig-name sig) (Sig-name sig))
                       (get-blame-node run-spec sig)))
    (define true-lower
      (remove-duplicates
        (append children-lowers
                (@or curr-lower (list)))))    
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  ; Helper to populate a lower bound based on a numeric scope given
  (define (fill-lower-by-scope sig)
    (define children-lowers
      (apply append (map fill-lower-by-scope (get-children run-spec sig))))
    ;(printf "fill-lower-by-scope case for ~a; chlds-lowers: ~a ~n" sig children-lowers)
    (define curr-lower-bound (get-bound-lower sig))
    (define curr-lower-scope (get-scope-lower-default sig))
    (define true-lower
      (remove-duplicates
        (if curr-lower-bound
            (append curr-lower-bound children-lowers)
            (append (generate-names sig (@- curr-lower-scope (length children-lowers))) children-lowers))))
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  (define (fill-upper-with-bound sig [parent-upper #f])
    (define curr-upper (get-bound-upper sig))
    (if curr-upper
        (let ()
          (hash-set! upper-bounds sig curr-upper)
          (map (lambda (child) (fill-upper-with-bound child curr-upper))
               (get-children run-spec sig)))
        (fill-upper-past-bound sig parent-upper)))

  (define (fill-upper-past-bound sig parent-upper)
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))
                       (get-blame-node run-spec sig)))
    (hash-set! upper-bounds sig parent-upper)
    (map (lambda (child) (fill-upper-past-bound child parent-upper))
         (get-children run-spec sig)))

  ; For use in situations where there is no existing upper (relational) bound
  (define (fill-upper-no-bound sig shared)

    ; If the sig has a relational upper bound, don't try to resolve the possible
    ; atom names etc.; ask the user to give an explicit bound on the parent, too.
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))
                       (get-blame-node run-spec sig)))
    (define curr-lower (hash-ref lower-bounds sig))

    ; Before doing anything else, confirm that if *no* scope was given for this sig,
    ; that the declared scopes for its children, combined, are not bigger than the default. 
    ; We allow a lower-bound to increase the default, but
    ; not a declared scope. This is consistent with Alloy, where many `one sig`s 
    ; can increase the default.
    (when (not (get-scope-upper sig))
      (define upper-budget
        (@max (length curr-lower)
              (get-scope-upper-default sig)))
      (define child-upper-declared-total
        (foldl (lambda (curr acc)
                 (@+ acc (or (get-scope-upper curr) 0)))
               0
               (get-children run-spec sig)))
      (when (< upper-budget child-upper-declared-total)
        (raise-run-error
         (format "Scope for ~a was not declared, so ~a would be used. \
However, the total of declared and inferred child-sig scopes was ~a. \
Please declare a sufficient scope for ~a."
                 (Sig-name sig) upper-budget child-upper-declared-total (Sig-name sig))
         (get-blame-node run-spec sig))))
    
    ; If the upper-bound's scope is bigger than the lower bound's current contents
    ;   (which should include child sigs' lower bounds), make room using atoms from parent.
    ; Otherwise, upper = lower, since there is no excess capacity.
    (if (@> (get-scope-upper-default sig) (length curr-lower))
        (hash-set! upper-bounds sig (append curr-lower shared))
        (hash-set! upper-bounds sig curr-lower))
    ; Recur on children
    (map (lambda (child) (fill-upper-no-bound child (append curr-lower shared)))
         (get-children run-spec sig)))

  ; List of all atoms that come from sigs, except Int. Will change as this procedure runs.
  (define sig-atoms (list))

  ; Start with each top-level sig
  (for ([root (get-top-level-sigs run-spec)]
        #:unless (equal? (Sig-name root) 'Int))
    (if (get-bound-upper root) ; Do we already have a tuple-based upper bound?
        (let ()           
          (fill-lower-by-bound root)
          (fill-upper-with-bound root))           
        (let ()
          (fill-lower-by-scope root) ; No tuple-based bound yet; extrapolate from scope
          (define lower-size (length (hash-ref lower-bounds root)))

          ; The budget for upper-bound atoms is either a declared size (if any) or
          ; the maximum of the lower-bound size and the default numeric bound (4). 
          (define upper-size
            (or (get-scope-upper root)
                (@max lower-size
                      (get-scope-upper-default root))))
          ;(printf "no-rel-bound case for ~a. scope=~a; default-scope:~a~n"
          ;        root (get-scope-upper root) (get-scope-upper-default root))

          ; Generate new names
          (define shared (generate-names root (@- upper-size lower-size)))
          ; This function is also responsible for validating totals (we didn't go over budget)
          (fill-upper-no-bound root shared)))
    ;(printf "filling bounds at ~a; upper = ~a; lower = ~a~n" root upper-bounds lower-bounds)
    (set! sig-atoms (append sig-atoms (hash-ref upper-bounds root))))

  ; Set the bounds for the Int built-in sig
  (define int-atoms
    (let* ([bitwidth (get-bitwidth run-spec)]
           [max-int (expt 2 (sub1 bitwidth))])
      (range (@- max-int) max-int)))
  (hash-set! lower-bounds (get-sig run-spec Int) int-atoms)
  (hash-set! upper-bounds (get-sig run-spec Int) int-atoms)

  ; Special case: allow sigs to extend Int.
  (define int-extenders (get-children run-spec Int))
  (for ([sig int-extenders])
    (hash-set! lower-bounds sig '())
    (hash-set! upper-bounds sig int-atoms))  

  (define all-atoms (append int-atoms sig-atoms))

  ; for ease of understanding, just sort by first atom
  (define (tuple<? t1 t2)
    (cond [(and (symbol? t1) (symbol? t2))
           (symbol<? (first t1) (first t2))]
          [(and (number? t1) (number? t2))
           (< (first t1) (first t2))]
          [else (symbol? t1)]))

  ; Map<Symbol, bound>
  (define bounds-hash
    (for/hash ([sig (get-sigs run-spec)])
      (let* ([name (Sig-name sig)]
             [rel sig]
             [lower (map list (hash-ref lower-bounds sig))]
             ; Override generated upper bounds for #:one sigs, unless they extend Int
             ; (In this case, we cannot generate an arbitrary atom for them, since Int atoms
             ;  have semantic value -- i.e., they are not isomorphic.)
             [upper
              (cond [(and (Sig-one sig) (not (member sig int-extenders)))
                     lower]
                    [else
                     (map list (hash-ref upper-bounds sig))])])
        ;(printf "bounds-hash at ~a; lower = ~a; upper = ~a; non-one upper = ~a~n" rel lower upper (hash-ref upper-bounds sig))                            
        (unless (subset? (list->set lower) (list->set upper))
          (raise-run-error (format "Bounds inconsistency detected for sig ~a: lower bound was ~a, which is not a subset of upper bound ~a." (Sig-name sig) lower upper)
                           (get-blame-node run-spec sig)))
        (values name (bound rel
                            (sort (remove-duplicates lower) tuple<?)
                            (sort (remove-duplicates upper) tuple<?))))))

;; Issue: one sig will overwrite with lower bound, but looking like that's empty if there's 
;;   an inst block that doesnt define it. Need to make that connection between default and provided.
;;   TODO  

  (values bounds-hash all-atoms))

; get-relation-info :: Run-spec -> Map<Symbol, bound>
; Given a Run-spec, the atoms assigned to each sig, the atoms assigned to each name,
; and the starting relation name, assigns names to each relation
; and minimum and maximum sets of atoms for each relation.
(define (get-relation-bounds run-spec sig-to-bound raise-run-error)
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))
  (define piecewise (Bound-piecewise (Run-spec-bounds run-spec)))
 
  (define (get-bound-lower rel)
    (define pbinding (hash-ref pbindings rel #f))
    (@and pbinding
          (sbound-lower pbinding)))
  (define (get-bound-upper rel)
    (define pbinding (hash-ref pbindings rel #f))
    (@and pbinding
          (sbound-upper pbinding)
          (sbound-upper pbinding)))
  (define (get-bound-piecewise rel)
    (hash-ref piecewise rel #f))

  (define without-succ
    (for/hash ([relation (get-relations run-spec)]
               #:unless (equal? (Relation-name relation) 'succ))
      (define sigs (get-sigs run-spec relation))
      (define sig-atoms (map (compose (curry map car )
                                      bound-upper
                                      (curry hash-ref sig-to-bound )
                                      Sig-name) 
                             sigs))
       ;(printf "~a: sig-atoms : ~a~n" relation sig-atoms)
       ;(printf "~a: raw upper : ~a~n" relation (get-bound-upper relation))
       ;(printf "~a: raw lower : ~a~n" relation (get-bound-lower relation))
      
      (define upper                   
        (let ([bound-upper (get-bound-upper relation)]
              [bound-piecewise (get-bound-piecewise relation)])
          (cond
            [(and bound-piecewise bound-upper)
             ; Error condition -- should never have both complete and piecewise on the same relation
             (raise-run-error (format "~a upper-bound had both complete and piecewise components, could not resolve them."
                                   relation)
                              (get-blame-node run-spec relation))]
            [bound-piecewise
             ;(printf "upper; bound-piecewise tuples: ~a~n" (PiecewiseBound-tuples bound-piecewise))
             ; for each admissible atom (taken from first component of the relation's declaration):
             ;   Where a piecewise entry exists: intersect with cartesian product of restricted universe.
             ;   otherwise: include the full cartesian-product for the restriction outside of that domain
             (define pw-domain (PiecewiseBound-atoms bound-piecewise))
             ;(printf "upper; sig-atoms[domain]: ~a~n" (first sig-atoms))
             ;(printf "upper; pw-domain: ~a~n" pw-domain) ; ISSUE: this is pre-eval :/ store post-eval?
             
             ; If the piecewise domain is not contained by the sig atoms, something has gone wrong;
             ; perhaps the sig was defined by numeric scope?
             (unless (subset? (list->set pw-domain) (list->set (first sig-atoms)))
               (define undeclared (set->list (set-subtract (list->set pw-domain) (list->set (first sig-atoms)))))
               (raise-run-error (format "Field ~a was bounded for atom(s): ~a, but the corresponding sig ~a contained only ~a. This might be caused by an inst or example not providing a value or bound for the sig; recall the default scope of ~a through ~a atoms will apply if no scope or bound is given."
                                        (Relation-name relation) undeclared (first sigs) (first sig-atoms) (Range-lower DEFAULT-SIG-SCOPE) (Range-upper DEFAULT-SIG-SCOPE))
                         (get-blame-node run-spec relation)))

             ; TODO: that only helps with the domain, not the range
             
             (define in-domain (set-intersect (list->set (PiecewiseBound-tuples bound-piecewise))
                                              (list->set (apply cartesian-product sig-atoms))))
             ;(printf "upper; sig-atoms product was: ~a~n" (apply cartesian-product sig-atoms))
             ;(printf "upper; in-domain: ~a~n" in-domain)
             (define out-of-domain (list->set
                                    (filter (lambda (tup)
                                              (not (member (first tup) pw-domain)))
                                            (apply cartesian-product sig-atoms))))
             ;(printf "upper; out-of-domain: ~a~n" out-of-domain)
             (set->list (set-union in-domain out-of-domain))]
            [bound-upper
             ; complete upper bound exists; intersect with the cartesian product of universe
             ; restricted to the sig-sequence in relation's declaration
             (set->list (set-intersect bound-upper
                                       (list->set (apply cartesian-product sig-atoms))))]
            [else
             ; no upper-bound given, default to cartesian product of universe, restricted
             ; to the sig-sequence in relation's declaration
             (apply cartesian-product sig-atoms)])))
      
      ;(define upper (set->list (set-intersect (get-bound-upper relation) (list->set (apply cartesian-product sig-atoms)))))
      ;(printf "~a: refined upper : ~a~n" relation upper)

      ; Piecewise lower bounds were handled in sigs-functional, before send-to-solver is called.
      (define lower                   
        (let ([bound-lower (get-bound-lower relation)])
            (if bound-lower
                (set->list (set-union bound-lower (list->set empty)))
                (list->set empty))))      
      ;(define lower (set->list (set-union (get-bound-lower relation) (list->set empty))))

      (unless (subset? (list->set lower) (list->set upper))
        (raise-run-error (format "Bounds inconsistency detected for field ~a: lower bound was ~a, which is not a subset of upper bound ~a." (Relation-name relation) lower upper)
                         (get-blame-node run-spec relation)))
      
      (values (Relation-name relation) 
              (bound relation lower upper))))
  
  (define ints (map car (bound-upper (hash-ref sig-to-bound 'Int))))
  (define succ-tuples (map list (reverse (rest (reverse ints))) (rest ints)))
  (hash-set without-succ 'succ (bound succ succ-tuples succ-tuples)))

; get-sig-size-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig to restrict
; it to the correct lower/upper bound.
(define (get-sig-size-preds run-spec sig-to-bound #:error raise-run-error) 
  (define max-int (expt 2 (sub1 (get-bitwidth run-spec))))
  (apply append
    (for/list ([sig (get-sigs run-spec)]
               #:unless (equal? (Sig-name sig) 'Int))
      (match-define (bound rel bound-lower bound-upper) (hash-ref sig-to-bound (Sig-name sig)))
      (define-values (bound-lower-size bound-upper-size) (values (length bound-lower) (length bound-upper)))
      (match-define (Range int-lower int-upper) 
        (hash-ref (Scope-sig-scopes (Run-spec-scope run-spec)) (Sig-name sig) (Range #f #f)))

      ; Sub-optimal, because it points to the sig definition
      (define info (nodeinfo (nodeinfo-loc (node-info sig)) 'checklangNoCheck #f))

      ; Do we need to enforce numeric scope by means other than bounds?
      ; (This can sometimes happen when a sig extends another and there is ambiguity
      ;  in how bounds should be resolved. e.g., sig A {} sig B extends A {}
      ;  run {} for 4 A, 3 B.
      (append
        (if (@and int-lower (@> int-lower bound-lower-size))
            (let ()
              (unless (@< int-lower max-int)
                (raise-run-error (format (string-append "Lower bound too large for given BitWidth; "
                                                        "Sig: ~a, Lower-bound: ~a, Max-int: ~a")
                                         sig int-lower (sub1 max-int))
                                 (get-blame-node run-spec sig)))
              (list (||/info info
                             (int</info info (int int-lower) (card sig))
                             (int=/info info (int int-lower) (card sig)))))
            (list))
        (if (@and int-upper (@< int-upper bound-upper-size))
            (let ()
              (unless (@< int-upper max-int)
                (raise-run-error (format (string-append "Upper bound too large for given BitWidth; "
                                                        "Sig: ~a, Upper-bound: ~a, Max-int: ~a")
                                         sig int-upper (sub1 max-int))
                                 (get-blame-node run-spec sig)))
              (list (||/info info
                             (int</info info (card sig) (int int-upper))
                             (int=/info info (card sig) (int int-upper)))))
            (list))))))


; TN TODO
; For many implicit constraints, it's either difficult or impossible to
; produce a *single* location to blame the formula on. For instance,
; the constraint that forces two sigs to be disjoint from one another
; can't be blamed solely on one of the two sigs.
; Instead, keep track of lists of sites for each implicit formula.

; get-extender-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig which has extending Sigs so that:
; - if it is abstract, then it must equal the sum of its extenders
; -                    else it must contain the sum of its extenders
; - all extenders are pair-wise disjoint.
(define (get-extender-preds run-spec)
  (define sig-constraints (for/list ([sig (get-sigs run-spec)])
    ; get children information
    (define children-rels (get-children run-spec sig))

    ; abstract and sig1, ... extend => (= sig (+ sig1 ...))
    ; not abstract and sig is parent of sig1 => (in sig1 sig)
    ; TODO: optimize by identifying abstract sigs as sum of children
    (define (abstract sig extenders)
      ; TODO : location not correct
      (let ([loc (nodeinfo-loc (node-info sig))])
        (if (@= (length extenders) 1)
            (=/info (nodeinfo loc 'checklangNoCheck #f) sig (car extenders))
            (=/info (nodeinfo loc 'checklangNoCheck #f) sig (+ extenders)))))
    (define (parent sig1 sig2)
      ; loc of sig2?
      (let ([loc (nodeinfo-loc (node-info sig2))])
        (in/info (nodeinfo loc 'checklangNoCheck #f) sig2 sig1)))

    (define extends-constraints 
      (if (and (Sig-abstract sig) (cons? (get-children run-spec sig)))
          (list (abstract sig children-rels))
          (map (curry parent sig) children-rels)))

    ; sig1 and sig2 extend sig => (no (& sig1 sig2))
    ; (unless both are #:one, in which case exact-bounds should enforce this constraint)
    (define (disjoin-pair sig1 sig2)
      (let* ([loc (nodeinfo-loc (node-info sig2))]
             [info (nodeinfo loc 'checklangNoCheck #f)])
        (cond [(and (Sig-one sig1) (Sig-one sig2)) true]
              [else (no/info info (&/info info sig1 sig2))])))
    (define (disjoin-list a-sig a-list)
      (map (curry disjoin-pair a-sig) a-list))
    (define (disjoin a-list)
      (if (empty? a-list)
          empty
          (append (disjoin-list (first a-list) (rest a-list))
                  (disjoin (rest a-list)))))
    (define disjoint-constraints (disjoin children-rels))

    (append extends-constraints disjoint-constraints)))

  ; combine all constraints together
  (apply append sig-constraints))

; get-relation-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Relation to ensure that it does not
; contain any atoms which don't populate their Sig.
(define (get-relation-preds run-spec)
  (for/list ([relation (get-relations run-spec)])
    (define sig-rels (get-sigs run-spec relation))
    (define info (nodeinfo (nodeinfo-loc (node-info relation)) 'checklangNoCheck #f))
    (in/info info relation (->/info info sig-rels))))

#|

Algorithm (draft) for bound generation:

lowerBound1(sig)
    (explicit lower bound or {}) union
    union of lowerBound(sig.children)

lowerBound2(sig)
    if sig has lower tuple bound
        lower tuple bound union union of lowerBound(sig.children)
    else
        union of lowerBound(sig.children) + generate names to make lower scope of sig


fillUpper1(current, [parentUpper #f]):
    if partialBounds.upper has current
        current.upper = partialBounds.upper(current)
        map fillUpper1(_, current.upper) onto current.children
    else
        fillUpper2(current, parentUpper)

fillUpper2(current, parentUpper):
    assert partialBounds.upper not has current
    current.upper = parentUpper
    map fillUpper2(_, current.upper) onto current.children

fillUpper3(current, shared):
    assert partialBounds.upper not has current
    current.upper = current.lower + shared
    map fillUpper3(_, shared) onto current.children

for root in root sigs
    if root has tuple upper bound
        fillUpper1(root)

    else (root does not have tuple upper bound)
        upperSize = 
            root's numerical upper bound, if present
            maximum of #root.lower and default upper

        shared = generate(upperSize - #root.lower)
        fillUpper3(root, shared)

|#